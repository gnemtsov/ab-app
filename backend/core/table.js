'use strict';

const fs = require('fs');
const DB = require('core/db');
const FORMATTERS = require('tables/formatters');

exports.getAsObject = tableName => {
    const sql = fs.readFileSync(`tables/sql/${tableName}.sql`, 'utf8');
    
	return new Promise( (resolve, reject) => {
		DB.query(
			sql,
			
			(error, sqlResult) => {
				if (error) {
					return reject(error);
				} else {
					const backendConf = {
						cols: require(`tables/configs/${tableName}.json`)
					}

					let frontendConf = {
						rows: [],
						cols: []
					};

					//make cols and order arrays
					for (let i in backendConf.cols) {
						if ( !backendConf.cols.hasOwnProperty(i) ) {
							continue;
						}						
						
						// Building col, which will be sent to client
						const col = {};
						const props = [
							'name',
							'title', 
							'defaultContent', 
							'sortOrder',
							'sortDirection'
						];
						for (const prop of props) {
							if ( backendConf.cols[i].hasOwnProperty(prop) ) {
								col[prop] = backendConf.cols[i][prop];
							}
						}
						// For forematter we send function's source code and parameters
						if ( backendConf.cols[i].hasOwnProperty('formatterFrontend') ) {
							const formatter = FORMATTERS[ backendConf.cols[i].formatterFrontend[0] ];
							const params = backendConf.cols[i].formatterFrontend.slice(1);
							
							col.formatter = {
								creator: [...formatter.params, formatter.f.toString().match(/function[^{]+\{([\s\S]*)\}$/)[1]],
								params: params
							};
						}
						
						frontendConf.cols.push(col);
					}

					for (const row of sqlResult) {
						const frontendRow = {};
						
						for (const col of backendConf.cols) {
							if (col.formatterBackend) {
								const formatter = FORMATTERS[ col.formatterBackend[0] ];
								const params = col.formatterBackend.slice(1);
								// Formatter can't use values generated by other formatters
								frontendRow[ col.name ] = formatter.f(...params)(row);
							} else {
								// "row" is loaded from DB, some fields are created by formatters on frontend
								// and not present in DB.
								// We add this fields with null values to "frontendRow", it's needed for frontend
								// TODO: move it to frontend
								frontendRow[ col.name ] = row.hasOwnProperty(col.name) ? row[ col.name ] : null;
							}
						}
						
						frontendConf.rows.push(frontendRow);
					}
					resolve(frontendConf);
				}
			}
		);
	});
}
